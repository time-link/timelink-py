from enum import Enum as PyEnum
import random
import math
from typing import Optional

from sqlalchemy import Enum, String, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .entity import Entity
from .base_class import Base


class REntityStatus(PyEnum):
    """
    Status of a real entity.

    The following statuses are possible:

    Default: unlinked entity, assumed as a real entity.
    Automatic: linked automatically by enetity resolution algorithms.
    Confirmed: linked by the user.
    Source: in the source transcription an identity link was recorded as "sameas" or "sameas"
    """

    DEFAULT = "Default"  # unlinked entity
    AUTOMATIC = "Automatic"  # linked automatically
    CONFIRMED = "Confirmed"  # confirmed by the user
    SOURCE = "Source"  # generated by sameas or xsameas in the source


class REntity(Entity):
    """
    Represents Real Entities in the database.

    Real entities are the result of entity resolution.
    They aggregate the information of several entities
    in the database that are believed to represent the same real-world entity.

    The representation supports reversing the entity resolution
    process. A mapping between the real entity and the entities
    that compose is maintained in the `links` table.

    We use the term "REntity" to avoid confusion with the term "entity",
    and often use to unlinked entities as "occurrences".

    Note that it is possible for an occurrence to be linked
    to more than one real entity. This can happen when the
    different users have different opinions about the identity
    of the entities.


    """

    __tablename__ = "rentities"
    __mapper_args__ = {"polymorphic_identity": "rentity"}

    id: Mapped[str] = mapped_column(
        String(64), ForeignKey(Entity.id), primary_key=True, on_delete="CASCADE"
    )
    user: Mapped[str] = mapped_column(
        String(64)
    )  # user that identified this real entity
    description: Mapped[str] = mapped_column(
        String(4096)
    )  # description of the real entity
    status: Mapped[REntityStatus] = mapped_column(
        Enum(REntityStatus), nullable=False
    )  # status of the real entity
    obs: Mapped[Optional[str]] = mapped_column(String)  # observations about the real entity

    occurrences: Mapped[list["Link"]] = relationship(
        "Link", back_populates="rentity"
    )  # One-to-many relationship

    def __repr__(self):
        sr = super().__repr__()
        return (
            f"REntity(id={sr}, "
            f"user={self.user}, "
            f"description={self.description}, "
            f"status={self.status}, "
            f"obs={self.obs}"
            f")"
        )

    # introspection
    def get_user(self):
        """ Get the user that identified this real entity """
        return self.user

    def set_user(self, user):
        """ Set the user that identified this real entity """
        self.user = user

    def get_description(self):
        """ Get the description of the real entity """
        return self.description

    def set_description(self, description):
        """ Set the description of the real entity """
        self.description = description

    def get_status(self):
        """ Get the status of the real entity """
        return self.status

    def set_status(self, status):
        """ Set the status of the real entity """
        self.status = status

    def get_obs(self):
        """ Get the observations about the real entity """
        return self.obs

    def set_obs(self, obs):
        """ Set the observations about the real entity """
        self.obs = obs

    def get_occurrences(self):
        """ Get the occurrences of the real entity """
        return self.occurrences

    @classmethod
    def get_rentity_brief(cls, rentity_id: str, session=None, db=None):
        """
        Fetch a real entity from the database
        """
        if session is not None:
            r: REntity = session.get(REntity, rentity_id)
        elif db is not None:
            with db.session() as session:
                r: REntity = session.get(REntity, rentity_id)
        else:
            raise ValueError("Error, session or db needed")
        return r

    @classmethod
    def get_rentity_full(cls, rentity_id: str, session=None, db=None):
        """
        Fetch a real entity from the database with all the
        attributes, relationships and contained objects of
        the occurrences of the real entity.

        I think this corresponds to an eager fetch in SQLAlchemy
        """

        if session is not None:
            # Fetch eargely the occurrences

            r: REntity = session.get(REntity, rentity_id)
        elif db is not None:
            with db.session() as session:
                r: REntity = session.get(REntity, rentity_id)
        else:
            raise ValueError("Error, session or db needed")

        return r

    @classmethod
    def same_as(cls, id1: str,
                id2: str,
                user="user",
                status="M",
                real_id=None,
                real_id_prefix=None,
                description=None,
                rule=None,
                session=None) -> str:
        """ Returns a real entity id linking id1 and id2.

        Args:
            id1: id of the first entity
            id2: id of the second entity
            user: user that linked the entities
            status: status of the link (default M)
            real_id: id of the real entity (if none a random id is generated)
            real_id_prefix: prefix of the generated real entity id
            description: description of the real entity (defaults to description or name of first entity)
            rule: rule used to link the entities
            session: database session

        if id1 and id2 are both unliked occurrences then a new real entity is created
            associated with user.  if real_id is given is not given a random id is generated.

        if id1 is a real entity and id2 is not, then id2 is added to id1 and id1 returned
        if id2 is a real entity and id1 is not, swap and do as above.
        if both id1 and id2 are real entities, merge them and keep the id of the real
            entity with higher status V->M->S->A->U

        in all the cases linking two id2 of different types or inheriting from a
        common type not equal to Entity is an error."""
        if session is None:
            raise ValueError("Error, session needed")

        with session:
            if id1 == id2:
                return cls.make_real(id1,
                                     user=user,
                                     status=status,
                                     real_id=real_id,
                                     real_id_prefix=real_id_prefix,
                                     description=description,
                                     rule=rule,
                                     session=session)

            # check if Entity id1 and id2 are of the same type
            eid1 = session.get(Entity, id1)
            eid2 = session.get(Entity, id2)
            if eid1 is None or eid2 is None:
                raise ValueError(f"Error, {id1} and {id2} must exist in the database")

            if eid1.pom_class != eid2.pom_class:
                raise ValueError(f"Error, {id1} and {id2} must be of the same type")

            # check if id1 and id2 are already linked
            # Query the links table for entity=id1 and user=user and return the rid
            # if it exists otherwise return None
            # if it exists return the rid
            r1 = session.query(Link.rid).filter(Link.entity == id1, Link.user == user).first()
            r2 = session.query(Link.rid).filter(Link.entity == id2, Link.user == user).first()

            if r1 is None and r2 is None:
                # both are unlinked occurrences

                if description is None:
                    desc = "<No description>"
                    if hasattr(eid1, "description"):
                        desc = eid1.description
                    elif hasattr(eid1, "name"):
                        desc = eid1.name
                else:
                    desc = description

                if rule is None:
                    rule = "sameas"

                if real_id is None:
                    real_id = cls.generate_id(session=session)

                r = REntity(id=real_id, user=user, description=desc, status=status)
                session.add(r)
                session.flush()
                l1 = Link(rid=real_id, entity=id1, user=user, status=status, rule=rule)
                l2 = Link(rid=real_id, entity=real_id, user=user, status=status, rule=rule)
                session.add(l1)
                session.add(l2)
                return real_id

            if r1 is not None and r2 is None:
                # r1 is a real entity and r2 is an occurrence
                link = Link(rid=id2, entity=id1, rule="sameas")
                session.add(link)
                return id1

            if r1 is None and r2 is not None:
                # r2 is a real entity and r1 is an occurrence
                link = Link(rid=id1, entity=id2, rule="sameas")
                session.add(link)
                return id2

            # both are real entities
            if r1.status.value > r2.status.value:
                # r1 is more important
                link = Link(rid=id2, entity=id1, rule="sameas")
                session.add(link)
                return id1

            # r2 is more important
            link = Link(rid=id1, entity=id2, rule="sameas")
            session.add(link)
            return id2
        return None

    @classmethod
    def generate_id(cls, length=6, session=None):
        """ Generate a random n digit id for a real entity

        Needs a section to test if already exists
        """
        if session is None:
            raise ValueError("Error, session needed")

        # storing strings in a list
        digits = [i for i in range(0, 10)]

        # initializing a string
        random_str = ""

        circuit_breaker = 1000000
        while True:
            circuit_breaker -= 1
            if circuit_breaker < 0:
                raise ValueError(f"Error, could not generate a unique id with {length} digits")
            random_str = ""
            for _i in range(length):
                # generating a random index
                index = math.floor(random.random() * 10)
                random_str += str(digits[index])
            # check if the id already exists
            if session.get(Entity, random_str) is None:
                break  # if not return
        return random_str

    @classmethod
    def make_real(cls, id1: str,
                  user="user",
                  status="M",
                  real_id=None,
                  real_id_prefix=None,
                  description=None,
                  rule=None,
                  session=None):
        """ Make an entity a real entity

        This creates a real entity from a single occurence
        """

        return None


class Link(Base):
    """
    Represents the link between a real entity and an entity.

    The link between a real entity and an entity is maintained in this table.
    """

    __tablename__ = "links"

    rid: Mapped[str] = mapped_column(
        String(64), ForeignKey(REntity.id, ondelete='CASCADE'), primary_key=True)
    entity: Mapped[str] = mapped_column(
        String(64), ForeignKey(Entity.id , ondelete='CASCADE'), primary_key=True)
    rule: Mapped[str] = mapped_column(
        String(4096)
    )  # rule used to link the entity to the real entity

    # The next two are redundant de normalized for efficiency
    user: Mapped[str] = mapped_column(String(64))  # user that linked the entity to the real entity

    status: Mapped[REntityStatus] = mapped_column(
        Enum(REntityStatus), nullable=False
    )  # status of the link

    rentity: Mapped[REntity] = relationship(
        REntity, back_populates="occurrences", foreign_keys=[rid]
    )  # Many-to-one relationship

    def __repr__(self):
        return f"Link(rid={self.rid}, entity={self.entity}, rule={self.rule})"
